import math

import matplotlib.pyplot as plt

import data_processing.VecRep
from visualization import Metrics, GraphEstimates
from visualization.Metrics import PlottingData, get_specified_ave_k_neighbour_score
import logging
import sys

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[logging.StreamHandler(sys.stdout)],
)


def investigate_k(plottingData: PlottingData, plotTitle:str, kArr = None, numK=16):
    """
    :param numK: Number of K swept before ending the sweep. inclusive
    :param plottingData:
    :return: Creates histogram of k distribution
    Remember to use plt.show() to display plots
    Aims to answer the question: What is the best value to choose for K?
    """
    sideLen = math.ceil(math.sqrt(numK))
    fig, axArr = plt.subplots(sideLen, sideLen)
    flat_list = []
    for sub_list in axArr:
        for ele in sub_list:
            flat_list.append(ele)

    if kArr is None:
        kArr = [i for i in range(1, numK + 1)]

    for k in kArr:
        try:
            GraphEstimates.plot_k_histograms(flat_list[k - 1], plottingData, k)
        except ValueError:
            logging.error("Value of numK is to high to sweep completely")
            break
    fig.suptitle("K neighbour score histograms for " + plotTitle)


def investigate_BF_method(plottingData: PlottingData, plotTitle: str, plottedImagesIndex=None, numSample=2):
    """
    :param plottedImagesIndex: Index of images you want to plot the k neighbours plot for
    :param numSample: Number of images to plot in the k neighbour plot
    :param plottingData:
    :return: Makes an eigenvalue graph
     swept k neighbours score graph for the mean K val and for a number of images
     and displays the frobenius distance for the embeddings
    Remember to use plt.show() to display plots

    Aims to answer the question: What is the error in using the selected method for generating embeddings?
    """
    # Comparing the largest and the most negative eigenvalues
    eigenFig, (ax1, ax2, ax3) = plt.subplots(3)
    eigenFig.suptitle("Eigenvalue plot and stats of " + plotTitle)
    GraphEstimates.plot_eigenvalues(ax1, ax2, plottingData.initialEigenvalues, plottingData.finalEigenvalues)
    GraphEstimates.plot_key_stats_text(ax3, plottingData)
    kNeighFig, axList = plt.subplots(numSample + 1, 2)
    kNeighFig.suptitle("Norm k neighbour plot for " + plotTitle)
    if numSample != 0:
        imgArr = [row[0] for row in axList[:-1]]
        kNeighArr = [row[1] for row in axList[:-1]]
    else:
        imgArr = []
        kNeighArr = []
    aveAx = axList[-1][1]
    # Set the bottom right subplot to be empty
    axList[-1][0].set_axis_off()
    GraphEstimates.plot_swept_k_neighbours(axArr=kNeighArr, imageAxArr=imgArr, aveAx=aveAx,
                                           kNormNeighbourScores=plottingData.kNormNeighbourScores,
                                           aveNormKNeighbourScores=plottingData.aveNormKNeighbourScore,
                                           imagesFilepath=plottingData.imagesFilepath, nImageSample=numSample,
                                           imageIndexArr=plottedImagesIndex)


def investigate_pencorr_rank_constraint(*, imageType: str, filters=None, imageProductType: str, startingConstr: int,
                                        endingConstr: int, specifiedKArr=None):
    """
    :param specifiedKArr: value of k for the k neighbour score
    :param imageType:
    :param filters:
    :param imageProductType:
    :param startingConstr: Starting lowest rank constraint to start the sweep inclusive
    :param endingConstr: Final largest rank constraint to end the sweep inclusive
    :return: Uses the penncorr method to generate embeddings for different rank constraints
    Makes a graph of the average neighbour score against rank_constraint and
    average frobenius distance against rank_constraint
    Remember to use plt.show() to display plots

    Aims to answer the question: How does the rank constraint affect the error of the embeddings generated by penncorr?
    """
    if startingConstr >= endingConstr:
        raise ValueError("Starting rank constraint must be lower than ending constraint")
    if specifiedKArr is None:
        specifiedKArr = [5]
    allAveNeighArr = []
    aveFrobDistanceArr = []
    rankConstraints = range(startingConstr, endingConstr + 1)
    for rank in rankConstraints:
        logging.info("Investigating rank " + str(rank) + "/" + str(endingConstr))
        embType = "pencorr_" + str(rank)
        plottingData = data_processing.VecRep.load_BF_plotting_data(imageType=imageType, filters=filters,
                                                                    imageProductType=imageProductType,
                                                                    embeddingType=embType)
        aveNeighArr = []
        for k in specifiedKArr:
            aveNeighArr.append(get_specified_ave_k_neighbour_score(plottingData.aveNormKNeighbourScore, k))
        allAveNeighArr.append(aveNeighArr)
        aveFrobDistanceArr.append(plottingData.aveFrobDistance)


    rankFig, axArr = plt.subplots(1, len(specifiedKArr) + 1)
    frobAx = axArr[-1]
    neighAx = axArr[:-1]
    GraphEstimates.plot_error_against_rank_constraint(frobAx, neighAx, rankConstraints, aveFrobDistanceArr, allAveNeighArr,
                                                      specifiedKArr)


def investigate_scaled_ncc(*, imageType: str, filters=None, imageProductType1: str, imageProductType2: str,
                           embeddingType: str, numPlottedK=None, overwrite=None):
    """
    :param imageType:
    :param filters:
    :param imageProductType1:
    :param imageProductType2:
    :param embeddingType:
    :param numPlottedK: number of K in the x axis for the k neighbour plot
    :return: Creates a figure for displaying the eigenvalue plots, basic stats and average neighbour score against k value for both image product 1 and image product 2

    Aims to answer the question: Does image product 1 result in better results than image product 2?
    """
    plottingData1 = data_processing.VecRep.load_BF_plotting_data(imageType=imageType, filters=filters,
                                                                 imageProductType=imageProductType1,
                                                                 embeddingType=embeddingType, overwrite=overwrite)
    plottingData2 = data_processing.VecRep.load_BF_plotting_data(imageType=imageType, filters=filters,
                                                                 imageProductType=imageProductType2,
                                                                 embeddingType=embeddingType, overwrite=overwrite)
    imgProd1Fig, ax1Arr = plt.subplots(4)
    ax1Arr = list(ax1Arr)
    imgProd1Fig.suptitle("Plots for " + imageProductType1)
    imgProd2Fig, ax2Arr = plt.subplots(4)
    ax2Arr = list(ax2Arr)
    imgProd2Fig.suptitle("Plots for " + imageProductType2)
    GraphEstimates.plot_comparison_btw_img_prod(ax1Arr, ax2Arr, imageProductType1, imageProductType2, plottingData1,
                                                plottingData2)


def get_plot_title(*, imageType: str, filters=None, imageProductType: str, embeddingType: str):
    if filters is None:
        filters = []
    return ("Image type: " + imageType + ", Filters: " + ''.join(filters) + ", Image product type: "
            + imageProductType + ", Embedding type: " + embeddingType)


if __name__ == '__main__':
    imageType = "4bin50max_ones"
    filters = ["one_island", "unique"]
    imageProductType = "ncc"
    embeddingType = "pencorr_20"
    overwrite = {"filter": False, "im_prod": False, "estimate": False, 'plot': False}
    plottingData = data_processing.VecRep.load_BF_plotting_data(imageType=imageType, filters=filters,
                                                                imageProductType=imageProductType,
                                                                embeddingType=embeddingType, overwrite=overwrite)
    plotTitle = get_plot_title(imageType=imageType, filters=filters,
                               imageProductType=imageProductType,
                               embeddingType=embeddingType)
    # General error analysis for one set of parameters
    investigate_BF_method(plottingData, plotTitle, numSample=3, plottedImagesIndex=[832, 114, 363])

    # Sweep rank constraint
    #investigate_pencorr_rank_constraint(imageType=imageType, filters=filters, imageProductType=imageProductType, startingConstr=5, endingConstr=40, specifiedKArr=[10])

    # Sweep the value of k
    # investigate_k(plottingData)

    # Carry out a general analysis for two image products
    # investigate_scaled_ncc(imageType=imageType,filters=filters, embeddingType=embeddingType, imageProductType1="ncc", imageProductType2="ncc_scaled", overwrite=overwrite )

    #investigate_k(plottingData, plotTitle)

    plt.show()
