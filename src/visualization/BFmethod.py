import math

import matplotlib.pyplot as plt

import data_processing.Utilities
from visualization import Metrics, GraphEstimates
import visualization.Metrics as metrics
from src.data_processing.BruteForceEstimator import BruteForceEstimator
import logging
import sys

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[logging.StreamHandler(sys.stdout)],
)


def investigate_k(bfEstimator: BruteForceEstimator, plotTitle: str, kArr=None, numK=16):
    """
    :param numK: Number of K swept before ending the sweep. inclusive
    :param plottingData:
    :return: Creates histogram of k distribution
    Remember to use plt.show() to display plots
    Aims to answer the question: What is the best value to choose for K?
    """
    if kArr is None:
        kArr = [i for i in range(1, numK + 1)]

    sideLen = math.ceil(math.sqrt(len(kArr))) # Find the size of the plotting area to fit in all the histograms
    fig, axArr = plt.subplots(sideLen, sideLen)
    flat_list = []
    for sub_list in axArr:
        for ele in sub_list:
            flat_list.append(ele)

    for k in kArr:
        try:
            GraphEstimates.plot_k_histograms(flat_list[k - 1], plottingData, k)
        except ValueError:
            logging.error("Value of numK is to high to sweep completely")
            break
    fig.suptitle("K neighbour score histograms for " + plotTitle)


def investigate_BF_method(bfEstimator: BruteForceEstimator, plotTitle: str, plottedImagesIndex=None, numSample=2):
    """
    :param bfEstimator: BruteForceEstimator to investigate
    :param plottedImagesIndex: Index of images you want to plot the k neighbours plot for
    :param numSample: Number of images to plot in the k neighbour plot
    :return: Makes an eigenvalue graph
     swept k neighbours score graph for the mean K val and for a number of images
     and displays the frobenius distance for the embeddings
    Remember to use plt.show() to display plots

    Aims to answer the question: What is the error in using the selected method for generating embeddings?
    """
    # Comparing the largest and the most negative eigenvalues
    eigenFig, (ax1, ax2, ax3) = plt.subplots(3)
    eigenFig.suptitle("Eigenvalue plot and stats of " + plotTitle)
    GraphEstimates.plot_eigenvalues(ax1, ax2, bfEstimator.initialEigenvalues, bfEstimator.finalEigenvalues)

    # Displaying stats
    GraphEstimates.plot_key_stats_text(ax3, bfEstimator)


def investigate_rank_constraint(*, imageType: str, filters=None, imageProductType: str, startingConstr: int,
                                endingConstr: int, interval=1, specifiedKArr=None, plotFrob=True):
    """
    :param specifiedKArr: value of k for the k neighbour score graph
    :param imageType:
    :param filters:
    :param imageProductType:
    :param startingConstr: Starting lowest rank constraint to start the sweep inclusive
    :param endingConstr: Final largest rank constraint to end the sweep inclusive
    :param interval: Interval for the rank sweep
    :return: Uses the penncorr method to generate embeddings for different rank constraints
    Makes a graph of the average neighbour score against rank_constraint and
    average frobenius distance against rank_constraint
    Remember to use plt.show() to display plots

    Aims to answer the question: How does the rank constraint affect the error of the embeddings generated by penncorr?
    """
    if startingConstr >= endingConstr:
        raise ValueError("Starting rank constraint must be lower than ending constraint")
    if specifiedKArr is None:
        specifiedKArr = [5]

    allAveNeighArr = [[] for i in specifiedKArr] # A list of k nieghbour plotting data, for each of the k in specified K array
    aveFrobDistanceArr = []
    rankConstraints = list(range(startingConstr, endingConstr + 1, interval))
    for rank in rankConstraints:
        logging.info("Investigating rank " + str(rank) + "/" + str(endingConstr))
        embType = "pencorr_" + str(rank)
        bfEstimator = BruteForceEstimator(imageType=imageType, filters=filters, imageProductType=imageProductType,
                                          embeddingType=embType)

        for i in range(len(specifiedKArr)):
            k = specifiedKArr[i]
            allAveNeighArr[i].append(metrics.get_mean_normed_k_neighbour_score(bfEstimator.matrixG,
                                                                               bfEstimator.matrixGprime, k))
        aveFrobDistanceArr.append(bfEstimator.aveFrobDistance)

    # Plot an additional graph if plotFrob
    if plotFrob:
        rankFig, axArr = plt.subplots(1, len(specifiedKArr) + 1)
        frobAx = axArr[-1]
        neighAx = axArr[:-1]
        GraphEstimates.plot_frob_error_against_rank_constraint(frobAx, rankConstraints, aveFrobDistanceArr)
    else:
        rankFig, neighAx = plt.subplots(1, len(specifiedKArr))
    GraphEstimates.plot_error_against_rank_constraint(neighAx, rankConstraints, allAveNeighArr, specifiedKArr)


def get_plot_title(*, imageType: str, filters=None, imageProductType: str, embeddingType: str):
    if filters is None:
        filters = []
    return ("Image type: " + imageType + ", Filters: " + ''.join(filters) + ", Image product type: "
            + imageProductType + ", Embedding type: " + embeddingType)


